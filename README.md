# openacc_introduction
Laboratory work of GPU programming course 

## Результаты работы

Написано два варианта заполнения массива значениями синуса и вычисления суммы этих значений: на [CPU](solution_cpu.c) и [GPU](solution_gpu.c).
Программа была собрана для CPU с флагом -O3, тем самым включается максимальная оптимизация программы (см. [Makefile](MakeFile)).
Также программа на CPU запускалась несколько раз, чтобы учесть то, что процессор может быть не прогретым, и также уменьшить вероятность 
разброса результата замера времени (среди всех замеров бралось наименьшее). 

Были написаны [бенчмарки](benchmarks.sh) для разных размеров массива и разных типов данных (float и double). Результаты сравнения сохранены в виде [csv-таблицы](results.csv). Можно заметить, что для варианта на CPU время работы растет линейно от размера входных данных, что нельзя сказать про вариант на GPU: время работы для всех размеров практически одинаковое. Это связано с высоким параллелизмом вычислений на GPU, поэтому рост времени работы заметен только с размера в 10 миллионов элементов. Также отмечу, что для массивов небольшого размера программа на CPU выигрывает программу на GPU. Скорее всего, это связяно с накладными расходами на координацию девайса и хоста.

Для массива размера 100'000'000 произведено профилирование программы на GPU, результате сохранен в [файле openacc_output.txt](openacc_output.txt). Из вывода видно, что основное время работы занимает создание массива на девайсе, также под это OpenACC создает отдельное ядро, и в результате у нас получается на 2 ядра, а **3**. Интересный момент, что 
```c++
#pragma acc kernels
```
создал массивы с более быстрой **shared memory**, что, скорее всего, еще ускорило программу.

Также интересны результаты самого суммирования. Если посмотреть для ARRAY_SIZE=500'000'000 и типа `float`, то программа на CPU дает совсем неправильные результаты. Это связано с тем, что сначала суммируются только положительные числа, и их достаточно много, чтобы аккумулятор дошел до такого значения, когда точность становится очень плохой: прибавление или вычитание маленького числа не меняет значение аккумулятора.

Что нельзя сказать про вариант на GPU: здесь результаты работы намного лучше, чем на CPU. Это связано с процедурой паралелльного суммирования в аккумулятор: скорее всего, каждый блок локально накапливает значение аккумулятора, а далее уже эти локальные значения аккумулятора суммируются в итоговую переменную, поэтому не получается такого, что к большим вещественным числам прибавляются маленькие вещесвенные числа.

Сумма элементов не равна нулю из-за представления чисел с плавающей точкой в компьютере. Суммирование значений по стандарту IEEE-754 является не только не ассоциативной операцией, но и имеет ошибку округления в результирующем числе.
